<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ðŸŒ¾ Unified Crop Yield Prediction</title>
  
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<style>
body {
  margin: 0;
  padding: 20px;
  background-color: #f4f9fc;
  font-family: 'Segoe UI', Arial, sans-serif;
  color: #333;
}

header {
  text-align: center;
  color: purple;
  padding: 40px 20px 10px;
}

.container {
  background-color: #e8f5e9;
  max-width: 1200px;
  margin: 0 auto;
  padding: 40px 20px;
  border-radius: 10px;
  box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
}

.action-buttons {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 20px;
  margin-bottom: 30px;
}

.btn-label, button, input[type="file"] {
  padding: 12px 20px;
  font-size: 16px;
  font-weight: bold;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.btn-label {
  background-color: white;
  color: red;
  min-width: 250px;
  text-align: center;
}

.btn-label:hover {
  background-color: #ffe5e5;
  transform: scale(1.03);
}

input[type="file"] {
  background: #fff;
  border: 2px dashed #ccc;
}

button:hover {
  opacity: 0.9;
}

.btn-green { background-color: #4caf50; color: white; }
.btn-blue { background-color: #2980b9; color: white; }

.logout-btn {
  position: absolute;
  top: 20px;
  right: 30px;
  background-color: red;
  color: white;
  border: none;
}

#fileNameDisplay {
  font-weight: bold;
  color: darkgreen;
  margin: 10px 0;
}

#output {
  margin-top: 20px;
  padding: 20px;
  background: #ffffff;
  border: 1px solid #ccc;
  border-radius: 10px;
  white-space: pre-wrap;
  font-family: monospace;
  max-height: 400px;
  overflow-y: auto;
}

table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 30px;
}

th, td {
  border: 1px solid #ccc;
  padding: 10px;
  text-align: center;
}

th {
  background: #3498db;
  color: white;
}

.prediction {
  font-weight: bold;
  color: #27ae60;
}

#chartContainer {
  margin-top: 40px;
}

canvas {
  background: white;
  border-radius: 10px;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
}
</style>

<body>
  <button class="logout-btn" onclick="logout()">Logout</button>

  <header>
    <h2>ðŸŒ¾ CROP YIELD PREDICTION USING RNN, LSTM, AND FEEDFORWARD NEURAL NETWORKS</h2>
  </header>

  <main class="container">
    <div class="action-buttons">
      <label for="fileInput" class="btn-label">Upload Agriculture Dataset</label>
      <input type="file" id="fileInput" accept=".csv" onchange="handleUpload(event)" style="display:none;" />
      <button class="btn-green" onclick="processData()">Preprocess Dataset</button>
      <button class="btn-green" onclick="trainModel('RNN')">Run RNN Algorithm</button>
      <button class="btn-green" onclick="trainModel('LSTM')">Run LSTM Algorithm</button>
      <button class="btn-green" onclick="predictWithFNN()">Run Feedforward Neural Network</button>
      <button class="btn-green" onclick="displayChart()">Show Accuracy Comparison</button>
      <button class="btn-green" onclick="location.href='states.html'">TOP States Crop Yield Production</button>

    </div>

    <div id="fileNameDisplay"></div>
    <div id="output">Upload your dataset...</div>
    <table id="dataTable"></table>
    <div id="result"></div>

    <div id="chartContainer">
      <canvas id="accuracyChart" width="800" height="400"></canvas>
    </div>
  </main>

  <script>
let csvData = [];
let r2Scores = { RNN: null, LSTM: null, FNN: null };

const output = document.getElementById('output');
const result = document.getElementById('result');
const dataTable = document.getElementById('dataTable');

function logout() {
  alert("Logged out successfully.");
  window.location.href = "login.html";
}

function handleUpload(event) {
  const file = event.target.files[0];
  if (!file) return;

  document.getElementById("fileNameDisplay").textContent = "Selected File: " + file.name;

  Papa.parse(file, {
    header: true,
    dynamicTyping: true,
    complete: function(results) {
      csvData = results.data.filter(row => Object.values(row).some(cell => cell !== ""));
      displayTable(csvData);
      output.innerText = "ðŸ“„ File loaded successfully.\n";
    }
  });
}

function displayTable(data) {
  if (!data.length) {
    dataTable.innerHTML = "";
    return;
  }
  
  const headers = Object.keys(data[0]);
  const thead = `<tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr>`;
  const tbody = data.map(row => 
    `<tr>${headers.map(h => `<td>${row[h]}</td>`).join('')}</tr>`
  ).join('');
  
  dataTable.innerHTML = thead + tbody;
}

function processData() {
  if (!csvData.length) {
    alert("Please upload a dataset first.");
    return;
  }
  output.innerText += "ðŸ›  Data preprocessing simulated...\n";
}

function encodeText(data, key) {
  const unique = [...new Set(data.map(row => row[key]))];
  const map = Object.fromEntries(unique.map((val, i) => [val, i]));
  return data.map(row => map[row[key]]);
}

async function trainModel(type) {
  if (!csvData.length) {
    alert("Please upload a dataset first.");
    return;
  }

  const filteredData = csvData.filter(d => d.place && d.rainfall != null && d.temperature != null && d.weather && d.yield != null);
  if (!filteredData.length) {
    alert("Dataset missing required columns (place, rainfall, temperature, weather, yield)!");
    return;
  }

  const placeEncoded = encodeText(filteredData, 'place');
  const weatherEncoded = encodeText(filteredData, 'weather');

  const inputs = filteredData.map((d, i) => [placeEncoded[i], d.rainfall, d.temperature, weatherEncoded[i]]);
  const labels = filteredData.map(d => [d.yield]);

  const inputTensor = tf.tensor2d(inputs);
  const labelTensor = tf.tensor2d(labels);

  const inputMax = inputTensor.max(0), inputMin = inputTensor.min(0);
  const labelMax = labelTensor.max(0), labelMin = labelTensor.min(0);

  const normalizedInputs = inputTensor.sub(inputMin).div(inputMax.sub(inputMin));
  const normalizedLabels = labelTensor.sub(labelMin).div(labelMax.sub(labelMin));

  const reshapedInputs = normalizedInputs.reshape([inputs.length, 1, 4]);

  const model = tf.sequential();
  model.add(type === "LSTM" 
    ? tf.layers.lstm({ units: 32, inputShape: [1, 4], activation: 'tanh' })
    : tf.layers.simpleRNN({ units: 16, inputShape: [1, 4], activation: 'relu' })
  );
  model.add(tf.layers.dense({ units: 1 }));

  model.compile({ optimizer: 'adam', loss: 'meanSquaredError' });

  output.innerText += `ðŸ§  Training ${type} model...\n`;

  await model.fit(reshapedInputs, normalizedLabels, {
    epochs: 50,
    callbacks: {
      onEpochEnd: (epoch, logs) => {
        output.innerText += `Epoch ${epoch + 1}: loss = ${logs.loss.toFixed(4)}\n`;
      }
    }
  });

  const predictions = model.predict(reshapedInputs);
  const unNormalizedPreds = predictions.mul(labelMax.sub(labelMin)).add(labelMin);
  const predsArray = await unNormalizedPreds.array();
  const labelsArray = labels;

  const r2 = calculateR2(predsArray, labelsArray);
  r2Scores[type] = r2.toFixed(3);

  output.innerText += `\nðŸŒŸ Predicted yield (${type}) for first row: ${predsArray[0][0].toFixed(2)} tons/ha\n`;
  output.innerText += `ðŸ“Š RÂ² Score (${type}): ${r2Scores[type]}\n`;
}

async function predictWithFNN() {
  if (!csvData.length) {
    alert("Please upload a dataset first.");
    return;
  }

  const filteredData = csvData.filter(d => d.rainfall != null && d.temperature != null && d.SoilQuality != null && d.yield != null);
  if (!filteredData.length) {
    alert("Dataset must contain rainfall, temperature, SoilQuality, and yield!");
    return;
  }

  const inputs = filteredData.map(d => [d.rainfall, d.temperature, d.SoilQuality]);
  const labels = filteredData.map(d => [d.yield]);

  const inputTensor = tf.tensor2d(inputs);
  const labelTensor = tf.tensor2d(labels);

  const inputMax = inputTensor.max(0), inputMin = inputTensor.min(0);
  const labelMax = labelTensor.max(0), labelMin = labelTensor.min(0);

  const normalizedInputs = inputTensor.sub(inputMin).div(inputMax.sub(inputMin));
  const normalizedLabels = labelTensor.sub(labelMin).div(labelMax.sub(labelMin));

  const model = tf.sequential();
  model.add(tf.layers.dense({ units: 16, activation: 'relu', inputShape: [3] }));
  model.add(tf.layers.dense({ units: 8, activation: 'relu' }));
  model.add(tf.layers.dense({ units: 1 }));

  model.compile({ optimizer: 'adam', loss: 'meanSquaredError' });

  output.innerText += `ðŸ§  Training Feedforward Neural Network (FNN)...\n`;

  await model.fit(normalizedInputs, normalizedLabels, {
    epochs: 50,
    callbacks: {
      onEpochEnd: (epoch, logs) => {
        output.innerText += `Epoch ${epoch + 1}: loss = ${logs.loss.toFixed(4)}\n`;
      }
    }
  });

  const predictions = model.predict(normalizedInputs);
  const unNormalizedPreds = predictions.mul(labelMax.sub(labelMin)).add(labelMin);
  const predsArray = await unNormalizedPreds.array();
  const labelsArray = labels;

  const r2 = calculateR2(predsArray, labelsArray);
  r2Scores["FNN"] = r2.toFixed(3);

  displayPredictionTable(filteredData, predsArray);

  output.innerText += `ðŸŒŸ FNN prediction completed.\nðŸ“Š RÂ² Score (FNN): ${r2Scores.FNN}\n`;
}

function calculateR2(predsArray, labelsArray) {
  const ssRes = predsArray.reduce((sum, p, i) => sum + Math.pow(p[0] - labelsArray[i][0], 2), 0);
  const meanLabel = labelsArray.reduce((sum, l) => sum + l[0], 0) / labelsArray.length;
  const ssTot = labelsArray.reduce((sum, l) => sum + Math.pow(l[0] - meanLabel, 2), 0);
  return 1 - (ssRes / ssTot);
}

function displayPredictionTable(data, predsArray) {
  let html = `<table><thead><tr>
    <th>Rainfall</th><th>Temperature</th><th>Soil Quality</th><th>Predicted Crop Yield</th>
  </tr></thead><tbody>`;

  data.forEach((row, i) => {
    html += `<tr>
      <td>${row.rainfall}</td>
      <td>${row.temperature}</td>
      <td>${row.SoilQuality}</td>
      <td class="prediction">${predsArray[i][0].toFixed(2)}</td>
    </tr>`;
  });

  html += '</tbody></table>';
  result.innerHTML = html;
}

function displayChart() {
  const ctx = document.getElementById('accuracyChart').getContext('2d');

  new Chart(ctx, {
    type: 'bar',
    data: {
      labels: ['RNN', 'LSTM', 'FNN'],
      datasets: [{
        label: 'RÂ² Score',
        data: [
          parseFloat(r2Scores.RNN) || 0,
          parseFloat(r2Scores.LSTM) || 0,
          parseFloat(r2Scores.FNN) || 0
        ],
        backgroundColor: ['#4caf50', '#2980b9', '#f39c12']
      }]
    },
    options: {
      responsive: true,
      scales: {
        y: {
          beginAtZero: true,
          max: 1
        }
      }
    }
  });
}
</script>
</body>
</html>
